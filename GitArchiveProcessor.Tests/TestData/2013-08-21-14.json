{
    "diff_hunk": "@@ -0,0 +1,190 @@\n+/* This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. \n+ */\n+\n+'use strict';\n+\n+const { Cc, Ci, Cu, ChromeWorker } = require(\"chrome\");\n+\n+Cu.import(\"resource://gre/modules/Services.jsm\");\n+\n+const { EventTarget } = require(\"sdk/event/target\");\n+const { emit, off } = require(\"sdk/event/core\");\n+const { Class } = require(\"sdk/core/heritage\");\n+const Environment = require(\"sdk/system/environment\").env;\n+const Runtime = require(\"runtime\");\n+const Self = require(\"self\");\n+const URL = require(\"url\");\n+const Subprocess = require(\"subprocess\");\n+const Promise = require(\"sdk/core/promise\");\n+\n+const { rootURI: ROOT_URI } = require('@loader/options');\n+const PROFILE_URL = ROOT_URI + \"profile/\";\n+\n+// Log subprocess error and debug messages to the console.  This logs messages\n+// for all consumers of the API.  We trim the messages because they sometimes\n+// have trailing newlines.  And note that registerLogHandler actually registers\n+// an error handler, despite its name.\n+Subprocess.registerLogHandler(\n+  function(s) console.error(\"subprocess: \" + s.trim())\n+);\n+Subprocess.registerDebugHandler(\n+  function(s) console.debug(\"subprocess: \" + s.trim())\n+);\n+\n+exports.SimulatorProcess = Class({\n+  extends: EventTarget,\n+  initialize: function initialize(options) {\n+    EventTarget.prototype.initialize.call(this, options);\n+\n+    this.on(\"stdout\", function onStdout(data) console.log(data.trim()));\n+    this.on(\"stderr\", function onStderr(data) console.error(data.trim()));\n+  },\n+\n+  // check if b2g is running\n+  get isRunning() !!this.process,\n+\n+  /**\n+   * Start the process and connect the debugger client.\n+   */\n+  run: function() {\n+    // resolve b2g binaries path (raise exception if not found)\n+    let b2gExecutable = this.b2gExecutable;\n+\n+    // kill before start if already running\n+    if (this.process != null) {\n+      this.process.kill();\n+    }\n+\n+    this.once(\"stdout\", function () {\n+      if (Runtime.OS == \"Darwin\") {\n+          console.debug(\"WORKAROUND run osascript to show b2g-desktop window\"+\n+                        \" on Runtime.OS=='Darwin'\");\n+        // Escape double quotes and escape characters for use in AppleScript.\n+        let path = b2gExecutable.path\n+          .replace(/\\\\/g, \"\\\\\\\\\").replace(/\\\"/g, '\\\\\"');\n+\n+        Subprocess.call({\n+          command: \"/usr/bin/osascript\",\n+          arguments: [\"-e\", 'tell application \"' + path + '\" to activate'],\n+        });\n+      }\n+    });  \n+\n+    let environment;\n+    if (Runtime.OS == \"Linux\") {\n+      environment = [\"TMPDIR=\" + Services.dirsvc.get(\"TmpD\",Ci.nsIFile).path];\n+      if (\"DISPLAY\" in Environment) {\n+        environment.push(\"DISPLAY=\" + Environment.DISPLAY);\n+      }\n+    }\n+\n+    // spawn a b2g instance\n+    this.process = Subprocess.call({\n+      command: b2gExecutable,\n+      arguments: this.b2gArguments,\n+      environment: environment,\n+\n+      // emit stdout event\n+      stdout: (function(data) {\n+        emit(this, \"stdout\", data);\n+      }).bind(this),\n+\n+      // emit stderr event\n+      stderr: (function(data) {\n+        emit(this, \"stderr\", data);\n+      }).bind(this),\n+\n+      // on b2g instance exit, reset tracked process, remoteDebuggerPort and\n+      // shuttingDown flag, then finally emit an exit event\n+      done: (function(result) {\n+        console.log(this.b2gFilename + \" terminated with \" + result.exitCode);\n+        this.process = null;\n+        emit(this, \"exit\", result.exitCode);\n+      }).bind(this)\n+    });\n+  },\n+\n+  // request a b2g instance kill\n+  kill: function() {\n+    if (this.process && !this.shuttingDown) {\n+      let deferred = Promise.defer();\n+      emit(this, \"kill\", null);\n+      this.shuttingDown = true;\n+      this.once(\"exit\", (exitCode) => {\n+        this.shuttingDown = true;\n+        deferred.resolve(exitCode);\n+      });\n+      this.process.kill();\n+      return deferred.promise;\n+    } else {\n+      return Promise.resolve(-1);",
            "position": 122
}